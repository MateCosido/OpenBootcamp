Características principales de los patrones de diseño más conocidos:
Patrones creacionales:------------------------------------------------------------------------------------------------------------------------------------
-Singleton 
Permite asegurarnos de que una clase tenga una única instancia, a la vez que proporciona un punto de acceso global a dicha instancia.

-Factory 
Permite producir familias de objetos relacionados sin especificar sus clases concretas.

-Builder 
Permite construir objetos complejos paso a paso. Este patrón nos permite producir distintos tipos y representaciones de un objeto
empleando el mismo código de construcción.

-Prototype 
Permite copiar objetos existentes sin que el código dependa de sus clases.

Patrones estructurales:-----------------------------------------------------------------------------------------------------------------------------------
-Decorator 
Permite añadir funcionalidades a objetos colocando estos objetos dentro de objetos encapsuladores especiales que contienen estas funcionalidades.

-Adapter 
Permite la colaboración entre objetos con interfaces incompatibles.

-Facade 
Proporciona una interfaz simplificada a una biblioteca, un framework o cualquier otro grupo complejo de clases.

Patrones de comportamiento:-----------------------------------------------------------------------------------------------------------------------------
-Iterator 
Permite recorrer elementos de una colección sin exponer su representación subyacente (lista, pila, árbol, etc.).

-Observer 
Permite definir un mecanismo de suscripción para notificar a varios objetos sobre cualquier evento que le suceda al objeto que están observando.

-Mediator 
Permite reducir las dependencias caóticas entre objetos. El patrón restringe las comunicaciones directas entre los objetos, 
forzándolos a colaborar únicamente a través de un objeto mediador.

-State 
Permite a un objeto alterar su comportamiento cuando su estado interno cambia. Parece como si el objeto cambiara su clase.

-Strategy 
Permite definir una familia de algoritmos, colocar cada uno de ellos en una clase separada y hacer sus objetos intercambiables.
